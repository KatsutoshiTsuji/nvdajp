NVDA notes for developers

NVDA structure

NVDA is very modular; it can be broken down in to clear parts.

NVDA is executed by nvda.pyw, which firstly redirects its stdout and stderr to the file stderr.log, starts debugging to the file debug.log and then executes core.main().

If core.main() returns True, then NVDA is exiting perfectly, if not, then this is a crash. nvda.pyw also plays startup, exit and crash sounds.

Debugging allows NVDA to write messages, errors or exceptions to the debug file from anywhere in its code. Messages are things like reporting that a key has been pressed, or that the focus has changed. Errors are things like something un expected happened, but it does not hinder the running of NVDA in any way. (NVDA does play an error sound if an error is written). Exceptions are written from the except part of a try  except block, and they will print the full traceback of the exception to the debug file, plus it will play an error sound.
 
core.main is what starts all the subsystems such as audio, gui, IAccessible etc, and then goes in to a while loop until a certain variable becomes false, which means something is telling NVDA to exit.

Inside the while loop, NVDA executes any functions found in the core queues, executes the next part of any generator objects found in the generators core queue, and then peaks, translates and dispatches the next window message received (to keep win events going).

The generator core queue and function core queues are used for functions that need to be executed in the main thread, but come from a user interface event (such as a focus change). These functions can only conain code that performs an action, but no return values can be collected by the origional event.

Use core.executeFunction to add a function to one of the queues. If you have a task that needs to loop, you should write it as a generator object, yielding when you would normally sleep, and then add it using core.newThread.

NVDA uses objects to represent the operating system. These objects (called NVDAObjects) have a particular set of methods and properties, yet they can be extended and replaced depending what type of Accessibility API is actually being represented by the object. This means that NVDA can talk to many different APIs, but to the user it seems to have the same look and feel over all.

There are a few important objects in NVDA:
The Desktop object - a reference to the Desktop window/object (the highest object, or root object, in the Operating system)
The focus object - This is a reference to What NVDA regards as the object currently with focus.
The foreground object - this is a reference to what NVDA currently regards as the object that is the foreground window/object (this could be an application's main window, or a dialog box etc).
The navigator object - This object is used to move around the operating system by object (with its next, previous, parent and first child properties).
The mouse object - the current object under the mouse

The reason NVDA keeps these objects is so that they can have their own memory. For example, if the focus is on a checkbox, NVDA can find out that it is unchecked, but when it receives a state change  event to become checked , because it new it was previously unchecked, now it can report that it is checked. Also, new objects do not have to be made all the time if for instance the focus object gets a whole lot of events at one time.

NVDA can have support for particular applications through what are called appModules. AppModules are special objects that stay around for the life of an application, and they can contain  particular code that should be executed on different user interface events for that application. Also, appModules can register specific NVDAObject types for that application, so that control-based logic can still be kept in objects, yet not have to live in the normal NVDA object code. For example, support for the MS Word _Wwg document view control is registered by the winword appModule, so when ever this control is found with in the winword application, NVDA will have the proper support for it in the NVDAObject it uses.

NVDA also has virtualBuffers, which are mostly used for web browser controls (such as in Internet Explorer or Firefox). These are used to render a flat document version of a web document that origionally was made up of hyerachical nodes. 

VirtualBuffers can have code for particular user interface events, they are dynamic, so they can be easily changed when new information is inserted or removed, and they can announce field types such as headings, paragraphs, form fields, lists and tables etc. Although a flat representation is rendered so that it can be arrowed up and down, the field types can still be hyerarchical (for example: list with 4 items bullet link heading level 1 My Favorite thins). This means that "my favorite things" is text that is with in a heading, inside a link, inside a list item, inside a list. Although these field types are announced when moving around, they arn't actually physically written in to the buffer, only the text exists.

NVDA responds to key presses via the keyboardHandler module, and also user interface events from different Accessibility APIs. Currently only IAccessible (or MSAA) is supported. However, it shouldn't be that hard to hook in any other API if an appropriate module is written for NVDA.

When a user interface event module receives an event (such as focus change, foreground change, name change, value change, reorder, state change, show, hide...), It should make sure that NVDA has a correct reference to the object with focus and the foreground object.
 
It should also see if the current appModule supports this event, if so, it should execute the appModule event in the main thread. If not, it should see if the current virtualBuffer supports the event and if so execute it in the main thread, and if not, finally instanciate an object refering to this event, and execute the event of this object.

